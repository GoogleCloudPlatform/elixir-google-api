# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# NOTE: This file is auto generated by the elixir code generator program.
# Do not edit this file manually.

defmodule GoogleApi.ManagedIdentities.V1.Model.LDAPSSettings do
  @moduledoc """
  LDAPSSettings represents the ldaps settings for domain resource. LDAP is the Lightweight Directory Access Protocol, defined in https://tools.ietf.org/html/rfc4511. The settings object configures LDAP over SSL/TLS, whether it is over port 636 or the StartTLS operation. If LDAPSSettings is being changed, it will be placed into the UPDATING state, which indicates that the resource is being reconciled. At this point, Get will reflect an intermediate state.

  ## Attributes

  *   `certificate` (*type:* `GoogleApi.ManagedIdentities.V1.Model.Certificate.t`, *default:* `nil`) - Output only. The certificate used to configure LDAPS. Certificates can be chained with a maximum length of 15.
  *   `certificatePassword` (*type:* `String.t`, *default:* `nil`) - Input only. The password used to encrypt the uploaded pfx certificate.
  *   `certificatePfx` (*type:* `String.t`, *default:* `nil`) - Input only. The uploaded PKCS12-formatted certificate to configure LDAPS with. It will enable the domain controllers in this domain to accept LDAPS connections (either LDAP over SSL/TLS or the StartTLS operation). A valid certificate chain must form a valid x.509 certificate chain (or be comprised of a single self-signed certificate. It must be encrypted with either: 1) PBES2 + PBKDF2 + AES256 encryption and SHA256 PRF; or 2) pbeWithSHA1And3-KeyTripleDES-CBC Private key must be included for the leaf / single self-signed certificate. Note: For a fqdn your-example-domain.com, the wildcard fqdn is *.your-example-domain.com. Specifically the leaf certificate must have: - Either a blank subject or a subject with CN matching the wildcard fqdn. - Exactly two SANs - the fqdn and wildcard fqdn. - Encipherment and digital key signature key usages. - Server authentication extended key usage (OID=1.3.6.1.5.5.7.3.1) - Private key must be in one of the following formats: RSA, ECDSA, ED25519. - Private key must have appropriate key length: 2048 for RSA, 256 for ECDSA - Signature algorithm of the leaf certificate cannot be MD2, MD5 or SHA1.
  *   `name` (*type:* `String.t`, *default:* `nil`) - The resource name of the LDAPS settings. Uses the form: `projects/{project}/locations/{location}/domains/{domain}`.
  *   `state` (*type:* `String.t`, *default:* `nil`) - Output only. The current state of this LDAPS settings.
  *   `updateTime` (*type:* `DateTime.t`, *default:* `nil`) - Output only. Last update time.
  """

  use GoogleApi.Gax.ModelBase

  @type t :: %__MODULE__{
          :certificate => GoogleApi.ManagedIdentities.V1.Model.Certificate.t() | nil,
          :certificatePassword => String.t() | nil,
          :certificatePfx => String.t() | nil,
          :name => String.t() | nil,
          :state => String.t() | nil,
          :updateTime => DateTime.t() | nil
        }

  field(:certificate, as: GoogleApi.ManagedIdentities.V1.Model.Certificate)
  field(:certificatePassword)
  field(:certificatePfx)
  field(:name)
  field(:state)
  field(:updateTime, as: DateTime)
end

defimpl Poison.Decoder, for: GoogleApi.ManagedIdentities.V1.Model.LDAPSSettings do
  def decode(value, options) do
    GoogleApi.ManagedIdentities.V1.Model.LDAPSSettings.decode(value, options)
  end
end

defimpl Poison.Encoder, for: GoogleApi.ManagedIdentities.V1.Model.LDAPSSettings do
  def encode(value, options) do
    GoogleApi.Gax.ModelBase.encode(value, options)
  end
end
